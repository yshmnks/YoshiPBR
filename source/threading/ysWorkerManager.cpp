#include "ysWorkerManager.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysWorkerManager::Reset()
{
    m_alarmSemaphore.Reset();
    m_workerCount = 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysWorkerManager::Create(ys_int32 workerCount)
{
    ysAssert(1 <= workerCount && workerCount <= ysWORKERMANAGER_CAPACITY);
    m_alarmSemaphore.Create(0);
    m_workerCount = workerCount;
    m_workers[0].CreateInForeground(this);
    for (ys_int32 i = 1; i < workerCount; ++i)
    {
        m_workers[i].CreateInBackground(this);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysWorkerManager::Destroy()
{
    for (ys_int32 i = 0; i < m_workerCount; ++i)
    {
        m_workers[i].Destroy();
    }
    m_workerCount = 0;

    m_alarmSemaphore.Destroy();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ysWorker* ysWorkerManager::GetForegroundWorker()
{
    ysAssert(m_workerCount > 0);
    ysAssertDebug(std::this_thread::get_id() == m_workers[0].m_threadId);
    return m_workers + 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ysWorker* ysWorkerManager::GetWorkerForThisThread()
{
    std::thread::id id = std::this_thread::get_id();
    ysAssert(m_workerCount > 0);
    for (ys_int32 i = 0; i < m_workerCount; ++i)
    {
        if (m_workers[i].m_threadId == id)
        {
            return m_workers + i;
        }
    }
    ysAssert(false); // Calling this API is a mistake if the worker could not be found.
    return nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ysJob* ysWorkerManager::StealJobForPerpetrator(const ysWorker* perpetrator)
{
    ys_int32 perpetratorIdx = ys_int32(perpetrator - m_workers);
    ysAssert(0 <= perpetratorIdx && perpetratorIdx < m_workerCount);
    for (ys_int32 i = 1; i < m_workerCount; ++i)
    {
        ys_int32 victimIdx = (perpetratorIdx + i) % m_workerCount;
        ysJob* loot = m_workers[victimIdx].m_jobQueue.Steal();
        if (loot != nullptr)
        {
            return loot;
        }
    }
    return nullptr;
}