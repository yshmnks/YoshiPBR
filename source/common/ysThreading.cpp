#include "YoshiPBR/ysThreading.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ysLock::ysLock()
{
    m_acquired = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysLock::Reset()
{
    m_acquired = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysLock::Acquire()
{
    bool anticipated = false;
    while (m_acquired.compare_exchange_weak(anticipated, true) == false)
    {
        // compare_exchange_weak mutates anticipated on failure, so we need to reset it.
        anticipated = false;
    }
    ysAssert(m_acquired);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ysLock::TryAcquire()
{
    bool anticipated = false;
    bool success = m_acquired.compare_exchange_weak(anticipated, true);
    return success;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysLock::Release()
{
    bool anticipated = true;
    bool success = m_acquired.compare_exchange_weak(anticipated, false);
    YS_REF(success);
    ysAssert(success);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ysScopedLock::ysScopedLock(ysLock* lock)
{
    lock->Acquire();
    m_lock = lock;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ysScopedLock::~ysScopedLock()
{
    m_lock->Release();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysSemaphore::Implementation
{
    // https://elweitzel.de/drupal/?q=node/6
    // TODO: Figure out how to avoid newing this damn thing. Because it currently relies on std::mutex and such, we need to call the
    //       constructor. Maybe we can do Placement New, but that just makes the code messier IMO.

    Implementation(ys_uint32 initialValue)
    {
        m_value = initialValue;
    }

    void Signal(ys_uint32 deltaValue)
    {
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            m_value += deltaValue;
        }
        m_condition.notify_all();
    }

    void Wait()
    {
        auto stopWaiting = [&]() { return m_value > 0; }; // Guard against spurious wakeups

        std::unique_lock<std::mutex> lock(m_mutex);
        m_condition.wait(lock, stopWaiting);
        m_value--;
    }

    std::condition_variable m_condition;
    std::mutex m_mutex;
    ys_uint32 m_value;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ysSemaphore::ysSemaphore()
{
    m_implementation = nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysSemaphore::Reset()
{
    m_implementation = nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysSemaphore::Create(ys_uint32 initialValue)
{
    m_implementation = ysNew Implementation(initialValue);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysSemaphore::Destroy()
{
    ysDelete(m_implementation);
    m_implementation = nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysSemaphore::Signal(ys_uint32 deltaValue)
{
    ysAssert(m_implementation != nullptr);
    m_implementation->Signal(deltaValue);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysSemaphore::Wait()
{
    ysAssert(m_implementation != nullptr);
    m_implementation->Wait();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysThread::Implementation
{
    Implementation(ysThreadFcn* fcn, void* fcnArg)
    {
        m_thread = std::thread(fcn, fcnArg);
    }

    ~Implementation()
    {
        if (m_thread.joinable())
        {
            m_thread.join();
        }
    }

    bool IsJoinable() const
    {
        return m_thread.joinable();
    }

    void Join()
    {
        m_thread.join();
    }

    std::thread::id GetID() const
    {
        return m_thread.get_id();
    }

    std::thread m_thread;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ysThread::ysThread()
{
    m_implementation = nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysThread::Reset()
{
    m_implementation = nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysThread::Create(ysThreadFcn* fcn, void* fcnArg)
{
    m_implementation = ysNew ysThread::Implementation(fcn, fcnArg);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysThread::Destroy()
{
    ysDelete(m_implementation);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ysThread::IsJoinable() const
{
    return (m_implementation == nullptr) ? false : m_implementation->IsJoinable();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysThread::Join()
{
    ysAssert(m_implementation != nullptr);
    m_implementation->Join();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
std::thread::id ysThread::GetID() const
{
    return (m_implementation == nullptr) ? std::thread::id() : m_implementation->GetID();
}