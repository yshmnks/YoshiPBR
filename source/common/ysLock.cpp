#include "YoshiPBR/ysLock.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ysLock::ysLock()
{
    m_acquired = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysLock::Reset()
{
    m_acquired = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysLock::Acquire()
{
    bool anticipated = false;
    while (m_acquired.compare_exchange_weak(anticipated, true) == false)
    {
        // compare_exchange_weak mutates anticipated on failure, so we need to reset it.
        anticipated = false;
    }
    ysAssert(m_acquired);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ysLock::TryAcquire()
{
    bool anticipated = false;
    bool success = m_acquired.compare_exchange_weak(anticipated, true);
    return success;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ysLock::Release()
{
    bool anticipated = true;
    bool success = m_acquired.compare_exchange_weak(anticipated, false);
    ysAssert(success);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ysScopedLock::ysScopedLock(ysLock* lock)
{
    lock->Acquire();
    m_lock = lock;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ysScopedLock::~ysScopedLock()
{
    m_lock->Release();
}