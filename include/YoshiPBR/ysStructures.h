#pragma once

#include "YoshiPBR/ysArrayG.h"
#include "YoshiPBR/ysMath.h"

struct ysDebugDraw;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysSceneId
{
    ys_int32 m_index;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysShapeId
{
    ys_int32 m_index;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysMaterialId
{
    ys_int32 m_index;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysEmissiveMaterialId
{
    ys_int32 m_index;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysRenderId
{
    ys_int32 m_sceneIdx;
    ys_int32 m_index;
};

extern const ysSceneId              ys_nullSceneId;
extern const ysShapeId              ys_nullShapeId;
extern const ysMaterialId           ys_nullMaterialId;
extern const ysEmissiveMaterialId   ys_nullEmissiveMaterialId;
extern const ysRenderId             ys_nullRenderId;

bool operator==(const ysSceneId&, const ysSceneId&);
bool operator!=(const ysSceneId&, const ysSceneId&);
bool operator==(const ysShapeId&, const ysShapeId&);
bool operator!=(const ysShapeId&, const ysShapeId&);
bool operator==(const ysMaterialId&, const ysMaterialId&);
bool operator!=(const ysMaterialId&, const ysMaterialId&);
bool operator==(const ysEmissiveMaterialId&, const ysEmissiveMaterialId&);
bool operator!=(const ysEmissiveMaterialId&, const ysEmissiveMaterialId&);
bool operator==(const ysRenderId&, const ysRenderId&);
bool operator!=(const ysRenderId&, const ysRenderId&);

enum struct ysMaterialType
{
    e_none,
    e_standard,
    e_mirror,
};

enum struct ysEmissiveMaterialType
{
    e_none,
    e_uniform,
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysShapeDef
{
    ysShapeDef()
    {
        m_materialType = ysMaterialType::e_none;
        m_materialTypeIndex = ys_nullIndex;
        m_emissiveMaterialType = ysEmissiveMaterialType::e_none;
        m_emissiveMaterialTypeIndex = ys_nullIndex;
    }

    ysMaterialType m_materialType;
    ys_int32 m_materialTypeIndex;

    ysEmissiveMaterialType m_emissiveMaterialType;
    ys_int32 m_emissiveMaterialTypeIndex;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysInputTriangle : public ysShapeDef
{
    // A free-standing triangle
    ysVec4 m_vertices[3];
    bool m_twoSided;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysMaterialStandardDef
{
    ysVec4 m_albedoDiffuse;
    ysVec4 m_albedoSpecular;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysMaterialMirrorDef
{
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysEmissiveMaterialUniformDef
{
    ysVec4 m_radiance;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysLightPointDef
{
    ysVec4 m_position;
    ysVec4 m_wattage;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysSceneDef
{
    ysSceneDef()
    {
        m_triangles = nullptr;
        m_triangleCount = 0;

        m_materialStandards = nullptr;
        m_materialStandardCount = 0;

        m_materialMirrors = nullptr;
        m_materialMirrorCount = 0;

        m_emissiveMaterialUniforms = nullptr;
        m_emissiveMaterialUniformCount = 0;

        m_lightPoints = nullptr;
        m_lightPointCount = 0;
    }

    ////////////
    // Shapes //
    ////////////

    const ysInputTriangle* m_triangles;
    ys_int32 m_triangleCount;

    //////////////////////////
    // Reflective Materials //
    //////////////////////////

    const ysMaterialStandardDef* m_materialStandards;
    ys_int32 m_materialStandardCount;

    const ysMaterialMirrorDef* m_materialMirrors;
    ys_int32 m_materialMirrorCount;

    ////////////////////////
    // Emissive Materials //
    ////////////////////////

    const ysEmissiveMaterialUniformDef* m_emissiveMaterialUniforms;
    ys_int32 m_emissiveMaterialUniformCount;

    ////////////////////////////////////////////////////////
    // Special lights with infinitesimal or infinite area //
    ////////////////////////////////////////////////////////

    const ysLightPointDef* m_lightPoints;
    ys_int32 m_lightPointCount;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysSceneRayCastInput
{
    ysSceneRayCastInput()
    {
        m_origin = ysVec4_zero;
        m_direction = ysVec4_unitZ;
        m_maxLambda = ys_maxFloat;
    }

    ysVec4 m_origin;
    ysVec4 m_direction;
    ys_float32 m_maxLambda;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysSceneRayCastOutput
{
    ysVec4 m_hitPoint;
    ysVec4 m_hitNormal;
    ysVec4 m_hitTangent;
    ys_float32 m_lambda;
    ysShapeId m_shapeId;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysGlobalIlluminationInput
{
    enum Type
    {
        e_undefined = -1,
        e_uniDirectional,
        e_biDirectional,
    };

    ysGlobalIlluminationInput()
    {
        m_type = e_undefined;
    }

    Type m_type;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysGlobalIlluminationInput_UniDirectional : public ysGlobalIlluminationInput
{
    ysGlobalIlluminationInput_UniDirectional()
    {
        m_type = Type::e_uniDirectional;
        m_sampleLight = true;
        m_maxBounceCount = 1;
    }

    // We always generate directions based on the BRDF. However, sometimes generating directions by sampling points on area lights may give
    // lower variance. Enable this if you wish to sample the lights directly; the results will be combined via Multiple Importance Sampling.
    // (Irrelevant for bidirectional path tracing as one of the two paths already starts at lights)
    bool m_sampleLight;

    // 1 is direct illumination only.
    ys_int32 m_maxBounceCount;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysGlobalIlluminationInput_BiDirectional : public ysGlobalIlluminationInput
{
    ysGlobalIlluminationInput_BiDirectional()
    {
        m_type = Type::e_biDirectional;
        m_maxLightSubpathVertexCount = 1;
        m_maxEyeSubpathVertexCount = 2;
    }

    ys_int32 m_maxLightSubpathVertexCount;
    ys_int32 m_maxEyeSubpathVertexCount;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysSceneRenderInput
{
    enum RenderMode
    {
        e_regular,
        e_compare,
        e_normals,
        e_depth,
    };

    ysSceneRenderInput()
    {
        m_eye = ysTransform_identity;
        m_fovY = 0.0f;
        m_pixelCountX = 0;
        m_pixelCountY = 0;
        m_samplesPerPixel = 16;
        m_samplesPerPixelCompare = 16;

        m_renderMode = RenderMode::e_regular;

        m_giInput = nullptr;
        m_giInputCompare = nullptr;
    }

    // For identity-eye-orientation, the eye looks down the -z axis (such that the x axis points right and y axis points up).
    ysTransform m_eye;

    // Vertical field of view in radians
    ys_float32 m_fovY;

    // Pixels are assumed to be "square,"  so the horizontal (x) fov is inferred from the pixel count aspect ratio.
    ys_int32 m_pixelCountX;
    ys_int32 m_pixelCountY;

    // We allow differing sample counts when comparing GI methods to account for the fact that a given method may exhibit lower or higher
    // variance depending on the scene. What is most important for verifying correctness is that the estimators converge to the same value.
    ys_int32 m_samplesPerPixel;
    ys_int32 m_samplesPerPixelCompare;

    RenderMode m_renderMode;

    const ysGlobalIlluminationInput* m_giInput;
    const ysGlobalIlluminationInput* m_giInputCompare;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysSceneRenderOutput
{
    ysSceneRenderOutput()
    {
        m_pixels.Create();
    }

    ysArrayG<ysFloat3> m_pixels;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysSceneRenderOutputIntermediate
{
    ysSceneRenderOutputIntermediate()
    {
        m_pixels.Create();
    }

    ysArrayG<ysFloat4> m_pixels;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysDrawInputBVH
{
    ysDrawInputBVH()
    {
        debugDraw = nullptr;
        depth = -1;
    }

    ysDebugDraw* debugDraw;

    // If negative, all nodes will be drawn. (depth=0 at the root and increases descending into the children)
    ys_int32 depth;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysDrawInputGeo
{
    ysDrawInputGeo()
    {
        debugDraw = nullptr;
    }

    ysDebugDraw* debugDraw;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ysDrawInputLights
{
    ysDrawInputLights()
    {
        debugDraw = nullptr;
    }

    ysDebugDraw* debugDraw;
};